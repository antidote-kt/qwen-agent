import os
import json
import time
import requests
import re
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from http import HTTPStatus
from typing import Optional, Dict, List, Any
from pathlib import Path

# å¼•å…¥ DashScope SDK (ç”¨äºè°ƒç”¨é€šä¹‰ä¸‡ç›¸)
import dashscope
from dashscope import ImageSynthesis, MultiModalConversation

# å¤ç”¨å¢å¼ºæç¤ºè¯æ¨¡å—ä¸­çš„å›¾åºŠä¸Šä¼ èƒ½åŠ›ï¼›åŒæ—¶æ”¯æŒç›´æ¥è½¬ä¸º Base64 Data URI
from enhanced_prompt import image_file_to_data_uri, file_url_to_local_path
from apimart_key import get_apimart_api_key

# Qwen-Agent åŸºç¡€ç»„ä»¶
from qwen_agent.agents import Assistant
from qwen_agent.tools.base import BaseTool, register_tool

# ==============================================================================
# 1. æ ¸å¿ƒå·¥å…·ï¼šæ‰¹é‡åˆ†é•œç»˜ç”»å·¥å…· (Wanxç‰ˆ)
# ==============================================================================

@register_tool('batch_storyboard_painter')
class BatchStoryboardPainter(BaseTool):
    description = 'åˆ†é•œç»˜åˆ¶å·¥å…·ã€‚è¯»å–åŒ…å«æç¤ºè¯çš„JSONæ–‡ä»¶ï¼Œæ‰¹é‡è°ƒç”¨é€šä¹‰ä¸‡ç›¸AIç»˜ç”»æ¨¡å‹ç”Ÿæˆåˆ†é•œå›¾ç‰‡ï¼Œå¹¶è¿”å›å›¾ç‰‡URLï¼ˆä¸åœ¨åç«¯å¼ºåˆ¶ä¸‹è½½ä¿å­˜ï¼‰ã€‚'
    parameters = [{
        'name': 'json_path',
        'type': 'string',
        'description': 'The path to the prompts.json file generated by the analysis step.',
        'required': True,
        },
        {
            'name': 'resolution',
            'type': 'string',
            'description': 'ç”Ÿæˆå›¾ç‰‡çš„åˆ†è¾¨ç‡ã€‚',
            'enum': ['1280*720', '720*1280', '1024*1024'], # é™åˆ¶å¯é€‰å€¼ï¼Œé˜²æ­¢æŠ¥é”™
            'required': False
        },
        {
            'name': 'json_content',
            'type': 'string',
            'description': 'ç›´æ¥ä¼ å…¥åˆ†é•œ JSON å­—ç¬¦ä¸²ï¼ˆåˆ—è¡¨ï¼‰ï¼Œç”¨äºä¸è½ç›˜åœºæ™¯ï¼›ä¸ json_path äºŒé€‰ä¸€ã€‚',
            'required': False
        },
        {
            'name': 'ref_image_dir',
            'type': 'string',
            'description': 'å‚è€ƒå›¾æ‰€åœ¨çš„æ–‡ä»¶å¤¹è·¯å¾„ã€‚æ–‡ä»¶åéœ€åŒ…å« shot_id (å¦‚ 01.png, scene_02.jpg)ã€‚',
            'required': False 
        },
        {
            'name': 'model_version',
            'type': 'string',
            'description': 'ä½¿ç”¨çš„æ¨¡å‹ç‰ˆæœ¬ï¼Œé»˜è®¤ä¸º wanx-v1ã€‚',
            'enum': ['wanx-v1'], # ç›®å‰SDKä¸»è¦æ”¯æŒv1ï¼Œæœªæ¥å¯åŠ v2
            'required': False
        },
        {
            'name': 'style_modifier',
            'type': 'string',
            'description': 'é¢å¤–çš„é£æ ¼ä¿®é¥°è¯ï¼Œä¼šè¿½åŠ åˆ°æ‰€æœ‰æç¤ºè¯åé¢ã€‚ä¾‹å¦‚ "anime style" æˆ– "black and white".',
            'required': False
        },
        {
            'name': 'save_images',
            'type': 'boolean',
            'description': 'æ˜¯å¦åœ¨æœ¬åœ°åˆ›å»ºä»»åŠ¡ç›®å½•å¹¶ä¿å­˜ç”Ÿæˆçš„å›¾ç‰‡æ–‡ä»¶ï¼Œé»˜è®¤ False ä»…è¿”å› URL ä¸è½ç›˜ã€‚',
            'required': False
        },
        {
            'name': 'max_workers',
            'type': 'integer',
            'description': 'å¹¶è¡Œç”Ÿæˆçš„æœ€å¤§çº¿ç¨‹æ•°ï¼ˆé»˜è®¤ 3ï¼‰ã€‚è¿‡å¤§ä¼šè§¦å‘è¶…æ—¶/é™æµã€‚',
            'required': False
        }
    ]

    def __init__(self, cfg: Optional[Dict] = None):
        super().__init__(cfg)
        # è·å– APIMart API Keyï¼ˆç”¨äºç”Ÿå›¾/å›¾ç”Ÿå›¾ï¼‰ã€‚
        # ä¸ºäº†æ–¹ä¾¿æœ¬åœ°æµ‹è¯•ï¼šè‹¥æœªè®¾ç½®ç¯å¢ƒå˜é‡ï¼Œåˆ™è‡ªåŠ¨è¯»å–ä»“åº“æ ¹ç›®å½•çš„ api key.txtã€‚
        self.apimart_api_key = (get_apimart_api_key() or '').strip()
        if not self.apimart_api_key:
            raise RuntimeError('Missing APIMART_API_KEY. Set env APIMART_API_KEY or put it in repo-root "api key.txt".')

        # ç”Ÿå›¾æ¨¡å‹é…ç½®ï¼ˆé»˜è®¤åˆ‡æ¢ä¸º Gemini-3-Pro-Image-preview / Nano banana2ï¼‰ã€‚
        # å¯ç”¨ç¯å¢ƒå˜é‡è¦†ç›–ï¼šAPIMART_IMAGE_MODEL / APIMART_IMAGE_RESOLUTION
        self.apimart_image_model = os.getenv('APIMART_IMAGE_MODEL', 'gemini-3-pro-image-preview').strip() or 'gemini-3-pro-image-preview'
        self.apimart_image_resolution = os.getenv('APIMART_IMAGE_RESOLUTION', '1K').strip() or '1K'

        # å›¾ç‰‡ä¿å­˜çš„æ ¹ç›®å½•ï¼ˆå½“å‰å®ç°é»˜è®¤ä¸è½ç›˜ï¼Œåªä¿ç•™ä¸ºå…¼å®¹å­—æ®µï¼‰
        self.output_root = "./generated_frames"
        if not os.path.exists(self.output_root):
            os.makedirs(self.output_root)

        # serialize expensive base64 conversions when running in parallel
        self._ref_cache_lock = threading.Lock()

    # ç”¨æ¥æ¸…é™¤ä¹‹å‰ç»™Midjorneyç”Ÿæˆçš„æç¤ºè¯ï¼Œå¯å»é™¤
    def _clean_prompt(self, prompt: str) -> str:
        if not prompt: return ""
        clean = prompt.replace("--ar 16:9", "").replace("--v 6.0", "").replace("/imagine prompt:", "")
        return clean.strip()
    
    def _find_ref_image(self, shot_id: str, ref_dir: str) -> Optional[str]:
        """è¾…åŠ©å‡½æ•°ï¼šæ ¹æ® shot_id åœ¨æ–‡ä»¶å¤¹é‡Œæ‰¾å›¾ç‰‡"""
        if not ref_dir:
            return None

        # allow file:// URLs from WebUI
        if isinstance(ref_dir, str) and ref_dir.startswith("file://"):
            try:
                ref_dir = file_url_to_local_path(ref_dir)
            except Exception:
                pass

        if not os.path.exists(ref_dir):
            return None

        # å¦‚æœä¼ å…¥çš„æ˜¯å•ä¸ªå›¾ç‰‡æ–‡ä»¶è·¯å¾„ï¼ˆè€Œä¸æ˜¯æ–‡ä»¶å¤¹ï¼‰ï¼Œ
        # åˆ™ç›´æ¥å°†è¿™å¼ å›¾ç‰‡ä½œä¸ºæ‰€æœ‰éœ€è¦å‚è€ƒå›¾çš„é•œå¤´çš„å‚è€ƒå›¾ã€‚
        if os.path.isfile(ref_dir):
            ext = os.path.splitext(ref_dir)[1].lower()
            if ext in ['.png', '.jpg', '.jpeg', '.webp']:
                return ref_dir
            return None

        # æ­£å¸¸æƒ…å†µï¼šä¼ å…¥çš„æ˜¯ç›®å½•ï¼ŒæŒ‰ shot_id åœ¨ç›®å½•ä¸­æŸ¥æ‰¾
        if not os.path.isdir(ref_dir):
            return None
        valid_exts = ['.png', '.jpg', '.jpeg', '.webp']
        matched = []
        for f in os.listdir(ref_dir):
            # ç®€å•åŒ¹é…ï¼šæ–‡ä»¶ååŒ…å« shot_id (å¦‚ shot_01.png åŒ¹é… 01)
            if shot_id in f:
                ext = os.path.splitext(f)[1].lower()
                if ext in valid_exts:
                    matched.append(os.path.join(ref_dir, f))
        if matched:
            return matched[0]
        # è‹¥æ²¡æœ‰åŒ…å« shot_id çš„æ–‡ä»¶ï¼Œä½†ç›®å½•é‡Œä»…æœ‰ä¸€å¼ å›¾ç‰‡ï¼Œåˆ™å…œåº•ä½¿ç”¨é‚£å¼ 
        fallback = [os.path.join(ref_dir, f) for f in os.listdir(ref_dir) if os.path.splitext(f)[1].lower() in valid_exts]
        if len(fallback) == 1:
            return fallback[0]
        return None
    def _map_resolution_to_apimart(self, resolution: str) -> str:
        """å°†æœ¬åœ°åˆ†è¾¨ç‡å‚æ•°æ˜ å°„ä¸º APIMart GPT-4o-image æ”¯æŒçš„æ¯”ä¾‹å­—ç¬¦ä¸²ã€‚

        APIMart å½“å‰æ”¯æŒçš„ size ä¸ºæ¯”ä¾‹å­—ç¬¦ä¸²ï¼š
        "1:1"ã€"2:3"ã€"3:2"ã€"3:4"ã€"4:3"ã€"4:5"ã€"5:4"ã€"9:16"ã€"16:9"ã€"21:9"ã€‚
        è¿™é‡Œæ ¹æ®å®½é«˜æ¯”é€‰æ‹©æœ€æ¥è¿‘çš„æ¯”ä¾‹ï¼›è‹¥æ— æ³•è§£æåˆ™é»˜è®¤ "1:1"ã€‚
        """

        supported = ["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9", "21:9"]
        if not resolution:
            return "1:1"

        res = resolution.strip()
        if res in supported:
            return res

        # å¤„ç†å½¢å¦‚ "1280*720" æˆ– "720*1280" çš„æ ¼å¼
        if "*" in res:
            try:
                w_str, h_str = res.split("*", 1)
                w, h = float(w_str), float(h_str)
                if w <= 0 or h <= 0:
                    raise ValueError
                ratio = w / h
                candidates = {
                    "1:1": 1.0,
                    "2:3": 2.0 / 3.0,
                    "3:2": 3.0 / 2.0,
                    "3:4": 3.0 / 4.0,
                    "4:3": 4.0 / 3.0,
                    "4:5": 4.0 / 5.0,
                    "5:4": 5.0 / 4.0,
                    "9:16": 9.0 / 16.0,
                    "16:9": 16.0 / 9.0,
                    "21:9": 21.0 / 9.0,
                }
                best = min(candidates.items(), key=lambda kv: abs(kv[1] - ratio))[0]
                print(f"  [Painter] åˆ†è¾¨ç‡ {res} å°†æ˜ å°„ä¸º APIMart æ”¯æŒçš„æ¯”ä¾‹ {best} ç”¨äºç”Ÿæˆã€‚")
                return best
            except Exception:
                pass

        # å…œåº•
        print(f"  [Painter] æœªèƒ½è§£æåˆ†è¾¨ç‡ {resolution}ï¼Œå°†ä½¿ç”¨é»˜è®¤æ¯”ä¾‹ 1:1ã€‚")
        return "1:1"

    def _generate_image(self, prompt: str, shot_id: str, save_dir: str, resolution: str, style_suffix: str, ref_image_url: Optional[str] = None, use_ref: bool = False) -> Optional[str]:
        """è°ƒç”¨ APIMart GPT-4o-image æ–‡ç”Ÿå›¾ / å›¾ç”Ÿå›¾æ¥å£å¹¶è¿”å›å›¾ç‰‡ URLã€‚"""

        print(f"  [Painter] æ­£åœ¨ç»˜åˆ¶é•œå¤´ {shot_id} ...")
        cleaned_prompt = self._clean_prompt(prompt)

        def _looks_like_chinese(s: str) -> bool:
            if not isinstance(s, str) or not s:
                return False
            try:
                cjk = len(re.findall(r"[\u4e00-\u9fff]", s))
            except Exception:
                cjk = 0
            return cjk >= 4

        def _has_image_instruction(s: str) -> bool:
            if not isinstance(s, str) or not s:
                return False
            sl = s.lower()
            # Chinese intent
            if any(k in s for k in ("ç”Ÿæˆä¸€", "ç”Ÿæˆä¸€å¹…", "ç”Ÿæˆä¸€å¼ ", "ç”»ä¸€", "ç»˜åˆ¶", "è¯·ç”»", "è¯·ç”Ÿæˆ", "ä½œä¸€å¹…")):
                return True
            # English intent
            if any(k in sl for k in ("generate an image", "generate a picture", "create an image", "draw", "illustration of", "render")):
                return True
            return False

        def _ensure_image_prompt(s: str) -> str:
            # Some image backends may return "no image" if prompt is purely descriptive.
            # Make the instruction explicit while preserving user content.
            s = (s or "").strip()
            if not s:
                return s

            # Strong constraint to avoid burned-in captions/watermarks.
            no_text = (
                "\n\nç¡¬æ€§çº¦æŸï¼šç”»é¢ä¸­ä¸è¦å‡ºç°ä»»ä½•å­—å¹•/æ–‡å­—/è´´ç‰‡/æ°´å°/Logo/UIç•Œé¢å…ƒç´ ã€‚"
                "\nHard constraint: NO subtitles/captions/on-screen text/overlays/watermarks/logos/UI elements."
            )

            if _has_image_instruction(s):
                return s + no_text

            if _looks_like_chinese(s):
                return f"è¯·ç”Ÿæˆä¸€å¹…é«˜è´¨é‡çš„å›¾åƒï¼š{s}" + no_text
            return f"Generate a high-quality image of: {s}" + no_text

        cleaned_prompt = _ensure_image_prompt(cleaned_prompt)

        if style_suffix:
            cleaned_prompt += f", {style_suffix}"

        size = self._map_resolution_to_apimart(resolution)

        payload: Dict = {
            "model": self.apimart_image_model,
            "prompt": cleaned_prompt,
            "size": size,
            "n": 1,
            "resolution": self.apimart_image_resolution,
        }

        # å¦‚æœæœ‰å‚è€ƒå›¾çš„å…¬ç½‘ URLï¼Œåˆ™ä½œä¸º image_urls ä¼ å…¥ï¼Œå¯ç”¨å¤šæ¨¡æ€ç”Ÿå›¾/å›¾ç”Ÿå›¾
        if use_ref and ref_image_url:
            payload["image_urls"] = [ref_image_url]
            if isinstance(ref_image_url, str) and ref_image_url.startswith("data:"):
                print(f"    -> ğŸ§© ä½¿ç”¨å‚è€ƒå›¾ï¼ˆdata URI, len={len(ref_image_url)}ï¼‰è¿›è¡Œå¤šæ¨¡æ€ç”Ÿæˆ")
            else:
                print(f"    -> ğŸ§© ä½¿ç”¨å‚è€ƒå›¾ URL è¿›è¡Œå¤šæ¨¡æ€ç”Ÿæˆ: {ref_image_url}")
        else:
            print("    -> ğŸ¨ çº¯æ–‡æœ¬æ–‡ç”Ÿå›¾ (æ— å‚è€ƒå›¾)")

        headers = {
            "Authorization": f"Bearer {self.apimart_api_key}",
            "Content-Type": "application/json",
        }

        def _safe_payload_for_log(p: Dict) -> Dict:
            try:
                cp = json.loads(json.dumps(p))
            except Exception:
                return {"_payload_unserializable": True}
            try:
                if isinstance(cp.get("prompt"), str):
                    txt = cp["prompt"]
                    cp["prompt_len"] = len(txt)
                    cp["prompt_preview"] = txt[:200]
                    cp["prompt"] = "<redacted>"
                if isinstance(cp.get("image_urls"), list) and cp["image_urls"]:
                    u = cp["image_urls"][0]
                    if isinstance(u, str) and u.startswith("data:"):
                        cp["image_urls"] = [f"<data_uri len={len(u)}>"]
                    elif isinstance(u, str):
                        cp["image_urls"] = [u[:200]]
            except Exception:
                pass
            return cp

        def _log_apimart_request(reason: str):
            try:
                print(f"  [Painter][Apimart] request debug ({reason}) shot={shot_id}:")
                print(json.dumps(_safe_payload_for_log(payload), ensure_ascii=False, indent=2)[:4000])
            except Exception:
                pass

        try:
            # å…è®¸é€šè¿‡ç¯å¢ƒå˜é‡è°ƒä¼˜è¶…æ—¶ï¼šAPIMART_CONNECT_TIMEOUT / APIMART_READ_TIMEOUT
            try:
                connect_timeout = float(os.getenv("APIMART_CONNECT_TIMEOUT", "20") or 20)
            except Exception:
                connect_timeout = 20.0
            try:
                read_timeout = float(os.getenv("APIMART_READ_TIMEOUT", "120") or 120)
            except Exception:
                read_timeout = 120.0
            # è½®è¯¢ä»»åŠ¡çŠ¶æ€çš„å•æ¬¡è¯»å–è¶…æ—¶ï¼ˆé»˜è®¤ 15sï¼‰ï¼Œé¿å…ä¸€æ¬¡ GET å¡å¤ªä¹…
            try:
                poll_read_timeout = float(os.getenv("APIMART_POLL_READ_TIMEOUT", "30") or 30)
            except Exception:
                poll_read_timeout = 30.0

            resp = requests.post(
                "https://api.apimart.ai/v1/images/generations",
                headers=headers,
                json=payload,
                timeout=(connect_timeout, read_timeout),
            )
        except Exception as e:
            print(f"    âŒ è°ƒç”¨ APIMart æ–‡ç”Ÿå›¾æ¥å£å¼‚å¸¸: {e}")
            _log_apimart_request(reason=f"exception:{e}")
            return None

        if resp.status_code != 200:
            print(f"    âŒ APIMart æ–‡ç”Ÿå›¾æ¥å£è¿”å›é”™è¯¯çŠ¶æ€ç  {resp.status_code}: {resp.text[:200]}")
            _log_apimart_request(reason=f"non_200:{resp.status_code}")
            return None

        try:
            data = resp.json()
        except Exception as e:
            print(f"    âŒ è§£æ APIMart æ–‡ç”Ÿå›¾å“åº” JSON å¤±è´¥: {e}")
            return None

        code = data.get("code")
        items = data.get("data") or []
        if code != 200 or not items:
            print(f"    âŒ APIMart æ–‡ç”Ÿå›¾è¿”å›å¼‚å¸¸å†…å®¹: {data}")
            return None

        task_id = items[0].get("task_id") or items[0].get("id")
        if not task_id:
            print(f"    âŒ æœªåœ¨ APIMart æ–‡ç”Ÿå›¾å“åº”ä¸­æ‰¾åˆ° task_id: {data}")
            return None

        print(f"    â³ æ–‡ç”Ÿå›¾ä»»åŠ¡å·²æäº¤åˆ° APIMartï¼Œtask_id={task_id}ï¼Œå¼€å§‹è½®è¯¢ä»»åŠ¡çŠ¶æ€...")

        # è½®è¯¢ä»»åŠ¡çŠ¶æ€
        status_url = f"https://api.apimart.ai/v1/tasks/{task_id}?language=zh"
        # æ€»è½®è¯¢æ—¶é•¿ï¼ˆé»˜è®¤ 180 ç§’ï¼‰ï¼Œé¿å…å› ä¸ºå•æ¬¡è¯·æ±‚æ…¢å¯¼è‡´æ•´ä½“ç­‰å¾…è¿‡ä¹…
        try:
            task_timeout_seconds = float(os.getenv("APIMART_TASK_TIMEOUT_SECONDS", "600") or 600)
        except Exception:
            task_timeout_seconds = 600.0
        if task_timeout_seconds <= 0:
            task_timeout_seconds = 180.0

        start_t = time.monotonic()
        i = 0
        while (time.monotonic() - start_t) < task_timeout_seconds:
            i += 1
            try:
                time.sleep(2)
                status_resp = requests.get(
                    status_url,
                    headers=headers,
                    timeout=(connect_timeout, poll_read_timeout),
                )
            except Exception as e:
                print(f"    âš ï¸ è½®è¯¢ç¬¬ {i + 1} æ¬¡ä»»åŠ¡çŠ¶æ€å¤±è´¥: {e}")
                continue

            if status_resp.status_code != 200:
                print(f"    âš ï¸ è½®è¯¢ä»»åŠ¡çŠ¶æ€è¿”å› {status_resp.status_code}: {status_resp.text[:200]}")
                continue

            try:
                status_data = status_resp.json().get("data") or {}
            except Exception as e:
                print(f"    âš ï¸ è§£æä»»åŠ¡çŠ¶æ€ JSON å¤±è´¥: {e}")
                continue

            status = status_data.get("status")
            progress = status_data.get("progress")
            print(f"    [Task {task_id}] çŠ¶æ€: {status}, è¿›åº¦: {progress}%")

            if status == "completed":
                try:
                    images = status_data.get("result", {}).get("images") or []
                    if not images:
                        print("    âš ï¸ ä»»åŠ¡å®Œæˆä½†æœªæ‰¾åˆ° images å­—æ®µã€‚")
                        return None
                    url_list = images[0].get("url") or []
                    if not url_list:
                        print("    âš ï¸ ä»»åŠ¡å®Œæˆä½†æœªæ‰¾åˆ°å›¾ç‰‡ URLã€‚")
                        return None
                    img_url = url_list[0]
                    print(f"    âœ… ç”ŸæˆæˆåŠŸ: {img_url}")
                    return img_url
                except Exception as e:
                    print(f"    âŒ è§£æä»»åŠ¡ç»“æœå¤±è´¥: {e}")
                    return None

            if status == "failed":
                error = status_data.get("error") or {}
                print(f"    âŒ APIMart æ–‡ç”Ÿå›¾ä»»åŠ¡å¤±è´¥: {error}")
                return None

        print(f"    âŒ APIMart æ–‡ç”Ÿå›¾ä»»åŠ¡è½®è¯¢è¶…æ—¶ï¼ˆ>{int(task_timeout_seconds)}sï¼‰ï¼Œå¯èƒ½ä»åœ¨æ’é˜Ÿæˆ–æ‰§è¡Œä¸­ã€‚")
        return None

    def _local_image_to_ref_url(self, local_path: str) -> Optional[str]:
        """å°†æœ¬åœ°å‚è€ƒå›¾è½¬æ¢ä¸º data URIï¼ˆä»…åœ¨å·¥å…·å†…éƒ¨ç”¨äºè¯·æ±‚ï¼Œä¸å›ä¼ ç»™ Agentï¼‰ã€‚"""
        if not local_path or not os.path.exists(local_path) or not os.path.isfile(local_path):
            return None

        # cache per tool instance (avoid repeated base64 work)
        cache = None
        try:
            cache = getattr(self, "_ref_data_uri_cache", None)
            if not isinstance(cache, dict):
                cache = {}
                setattr(self, "_ref_data_uri_cache", cache)
            cached = cache.get(local_path)
            if isinstance(cached, str) and cached:
                return cached
        except Exception:
            cache = None

        # æ§åˆ¶å¤§å°ï¼Œé¿å…è¯·æ±‚ä½“è¿‡å¤§å¯¼è‡´è¶…æ—¶/è¢«æ‹’
        MAX_LOCAL_IMAGE_BYTES = 5 * 1024 * 1024  # 5MB
        try:
            size = os.path.getsize(local_path)
        except Exception:
            size = None
        if size is not None and size > MAX_LOCAL_IMAGE_BYTES:
            print(f"  [Painter] âš ï¸ å‚è€ƒå›¾è¶…è¿‡ 5MBï¼ˆ{size} bytesï¼‰ï¼Œå°†ä¸ä½¿ç”¨å‚è€ƒå›¾ï¼š{local_path}")
            return None

        # NOTE: ç”¨æˆ·æ˜ç¡®ä¸ä½¿ç”¨å›¾åºŠï¼Œå¼ºåˆ¶èµ° data URIã€‚
        # ä¸ºäº†å‡å°‘è¶…æ—¶æ¦‚ç‡ï¼Œå¯é€‰åœ°å¯¹å¤§å›¾è¿›è¡Œæœ¬åœ°å‹ç¼©/ç¼©æ”¾ï¼ˆä»ç„¶æ˜¯ base64ï¼‰ã€‚
        MAX_DATA_URI_BYTES = 200 * 1024  # 200KBï¼ˆç»éªŒé˜ˆå€¼ï¼›è¶…è¿‡ä¼šæ˜¾è‘—å¢åŠ è¶…æ—¶æ¦‚ç‡ï¼‰
        if size is not None and size > MAX_DATA_URI_BYTES:
            try:
                max_dim = int(os.getenv("REF_IMAGE_MAX_DIM", "1024") or 1024)
            except Exception:
                max_dim = 1024
            try:
                quality = int(os.getenv("REF_IMAGE_JPEG_QUALITY", "85") or 85)
            except Exception:
                quality = 85
            try:
                target_max_bytes = int(os.getenv("REF_IMAGE_MAX_BYTES", str(800 * 1024)) or (800 * 1024))
            except Exception:
                target_max_bytes = 800 * 1024

            if max_dim > 0 and target_max_bytes > 0:
                try:
                    from PIL import Image  # type: ignore
                    import io

                    print(
                        f"  [Painter] ğŸ§© å‚è€ƒå›¾è¾ƒå¤§({size} bytes)ï¼Œå°†å°è¯•æœ¬åœ°å‹ç¼©/ç¼©æ”¾ä¸º JPEGï¼ˆä»ç”¨ base64ï¼‰ï¼Œ"
                        f"max_dim={max_dim}, quality={quality}, target<={target_max_bytes} bytes"
                    )
                    with Image.open(local_path) as im:
                        im = im.convert("RGB")
                        w, h = im.size
                        scale = min(1.0, max_dim / float(max(w, h)))
                        if scale < 1.0:
                            im = im.resize((int(w * scale), int(h * scale)), Image.LANCZOS)

                        # try a few qualities to fit target bytes
                        buf = io.BytesIO()
                        q = max(30, min(95, quality))
                        best = None
                        for q_try in (q, max(30, q - 10), max(30, q - 20), 30):
                            buf.seek(0)
                            buf.truncate(0)
                            im.save(buf, format="JPEG", quality=q_try, optimize=True)
                            b = buf.getbuffer().nbytes
                            if b <= target_max_bytes:
                                best = ("jpeg", q_try, buf.getvalue())
                                break
                            if best is None or b < len(best[2]):
                                best = ("jpeg", q_try, buf.getvalue())

                        if best is not None and best[2]:
                            mime = "image/jpeg"
                            import base64

                            data_b64 = base64.b64encode(best[2]).decode("ascii")
                            u = f"data:{mime};base64,{data_b64}"
                            print(f"  [Painter] âœ… å‹ç¼©å: mime={mime}, bytes={len(best[2])}, data_uri_len={len(u)}")
                            if isinstance(cache, dict) and u:
                                cache[local_path] = u
                            return u
                except Exception as e:
                    print(f"  [Painter] âš ï¸ å‚è€ƒå›¾å‹ç¼©/ç¼©æ”¾å¤±è´¥ï¼ˆå°†ç›´æ¥ä½¿ç”¨åŸå›¾ base64ï¼‰ï¼š{e}")

        print(f"  [Painter] ğŸ§© å‚è€ƒå›¾å°†è¿›è¡Œ Base64 è½¬æ¢ï¼š{local_path}")
        u = image_file_to_data_uri(local_path)
        if isinstance(cache, dict) and u:
            cache[local_path] = u
        return u


    def call(self, params: str, **kwargs) -> str:
        # 1. è§£æå‚æ•°
        try:
            params_dict = json.loads(params)
            json_path = params_dict.get('json_path')
            json_content_raw = params_dict.get('json_content')
            # --- è·å–å¯é€‰å‚æ•°ï¼Œè®¾ç½®é»˜è®¤å€¼ ---
            ref_image_dir = params_dict.get('ref_image_dir', None)
            # allow file:// URLs from WebUI
            if isinstance(ref_image_dir, str) and ref_image_dir.startswith("file://"):
                try:
                    ref_image_dir = file_url_to_local_path(ref_image_dir)
                except Exception:
                    pass
            resolution = params_dict.get('resolution', '1280*720')
            style_modifier = params_dict.get('style_modifier', '')
            save_images = bool(params_dict.get('save_images', False))
            max_workers = params_dict.get('max_workers', None)
        except:
            return "Error: Invalid parameters. Please provide 'json_path' or 'json_content'."

        if not json_path and json_content_raw is None:
            return "Error: Please provide either 'json_path' or 'json_content'."

        # å¹¶è¡Œå‚æ•°ï¼šmax_workersï¼ˆå‚æ•° > ç¯å¢ƒå˜é‡ > é»˜è®¤ 1ï¼‰
        try:
            if max_workers is None:
                max_workers = int(os.getenv("STORYBOARD_MAX_WORKERS", "3") or 3)
            else:
                max_workers = int(max_workers)
        except Exception:
            max_workers = 3
        if max_workers < 1:
            max_workers = 1
        max_workers = min(max_workers, 8)

        # 2. åˆ›å»ºæœ¬æ¬¡ä»»åŠ¡çš„ä¿å­˜ç›®å½• (æŒ‰æ—¶é—´æˆ³éš”ç¦») â€”â€” ä»…åœ¨éœ€è¦è½ç›˜æ—¶æ‰åˆ›å»º
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        task_dir = os.path.join(self.output_root, f"task_{timestamp}")
        if save_images:
            os.makedirs(task_dir, exist_ok=True)

        generated_files = []
        # è®°å½•æ¯ä¸ªä½¿ç”¨äº†å‚è€ƒå›¾çš„é•œå¤´å¯¹åº”çš„å…¬ç½‘ URLï¼ˆé€šè¿‡å›¾åºŠï¼Œå¦‚ SM.MSï¼‰
        ref_image_public_urls: Dict[str, str] = {}
        ref_image_used: Dict[str, bool] = {}
        warnings: List[str] = []
        failed_shots = []

        try:
            # 3. è¯»å– JSON
            if json_content_raw is not None:
                if isinstance(json_content_raw, str):
                    shots_data = json.loads(json_content_raw)
                else:
                    shots_data = json_content_raw
            else:
                if not os.path.exists(json_path):
                    return f"Error: File not found: {json_path}"
                with open(json_path, 'r', encoding='utf-8') as f:
                    shots_data = json.load(f)

            print(f"  [Painter] å¼€å§‹ä»»åŠ¡ã€‚åˆ†è¾¨ç‡: {resolution}, é£æ ¼è¿½åŠ : {style_modifier}")

            # 4. éå†ç”Ÿæˆ
            image_by_shot: Dict[str, str] = {}
            images_with_shot_id: list = []
            tasks: List[Dict[str, Any]] = []
            for shot in shots_data:
                # å…¼å®¹ä¸åŒä¸Šæ¸¸å­—æ®µå‘½åï¼š
                # - æœ‰çš„ä¸Šæ¸¸ä¼šç»™ id/descriptionï¼ˆè€Œé shot_id/t2i_promptï¼‰
                # - è¿™é‡Œåšä¸€æ¬¡å½’ä¸€åŒ–ï¼Œé¿å…å‡ºç° â€œshot unknown / ç¼ºå°‘æç¤ºè¯â€ å¯¼è‡´å…¨éƒ¨è·³è¿‡
                if isinstance(shot, dict):
                    if "shot_id" not in shot and "id" in shot:
                        shot["shot_id"] = str(shot.get("id"))
                    if not (shot.get("t2i_prompt") or shot.get("midjourney_prompt")) and shot.get("description"):
                        shot["t2i_prompt"] = str(shot.get("description"))

                shot_id = shot.get('shot_id', 'unknown')
                # ä¼˜å…ˆè¯»å– midjourney_promptï¼Œå¦‚æœæ²¡æœ‰åˆ™å°è¯•è¯»å–å…¶ä»–å­—æ®µ
                raw_prompt = shot.get('midjourney_prompt') or shot.get('t2i_prompt')

                wants_ref = bool(
                    shot.get('ref', False)
                    or (isinstance(shot.get("keyframe_url"), str) and shot.get("keyframe_url").strip())
                )

                # å°è¯•æ ¹æ®æä¾›çš„ ref_image_dir æŸ¥æ‰¾æœ¬åœ°å‚è€ƒå›¾ï¼ˆä¼˜å…ˆä½¿ç”¨æœ¬åœ°å›¾ç‰‡çš„ Base64 Data URIï¼‰
                ref_public_url = None
                current_ref_path = None
                # IMPORTANT: ref_image_dir should NOT be applied to all shots blindly.
                # Only use ref_image_dir when the shot explicitly requests reference (ref=true or keyframe_url is set).
                if ref_image_dir and wants_ref:
                    current_ref_path = self._find_ref_image(shot_id, ref_image_dir)
                    if current_ref_path:
                        try:
                            # ä¼˜å…ˆä¸Šä¼ åˆ°å›¾åºŠè·å–çŸ­ URLï¼›ä¸Šä¼ å¤±è´¥åˆ™é™çº§ä¸ºæ–‡ç”Ÿå›¾ï¼ˆä¸ä½¿ç”¨å‚è€ƒå›¾ï¼‰
                            ref_public_url = self._local_image_to_ref_url(current_ref_path)
                            if ref_public_url:
                                if ref_public_url.startswith("http://") or ref_public_url.startswith("https://"):
                                    ref_image_public_urls[shot_id] = ref_public_url
                                if ref_public_url.startswith("data:"):
                                    print(
                                        f"  [Painter] ğŸ§© å‚è€ƒå›¾å·²è½¬æ¢ä¸º data URI (Shot {shot_id}, len={len(ref_public_url)}), å°†ç›´æ¥ä¼ ç»™æ¨¡å‹ç”Ÿæˆã€‚"
                                    )
                                else:
                                    print(
                                        f"  [Painter] ğŸ§© å‚è€ƒå›¾å·²ä¸Šä¼ å¹¶è·å¾— URL (Shot {shot_id}), å°†ç›´æ¥ä¼ ç»™æ¨¡å‹ç”Ÿæˆã€‚"
                                    )
                        except Exception as e:
                            print(f"  [Painter] âš ï¸ å‚è€ƒå›¾å¤„ç†å¤±è´¥ (Shot {shot_id}): {e}")
                        if not ref_public_url and shot.get('ref', False):
                            msg = f"Shot {shot_id}: æœªèƒ½ä½¿ç”¨å‚è€ƒå›¾ï¼Œå·²æ”¹ä¸ºæ–‡ç”Ÿå›¾ï¼ˆå›¾ç‰‡æœªä½¿ç”¨ï¼‰ã€‚"
                            warnings.append(msg)
                            print(f"  [Painter] âš ï¸ {msg}")
                    else:
                        # ä»…åœ¨é•œå¤´æ˜¾å¼æ ‡æ³¨ ref=true æ—¶å‘å‡ºè­¦å‘Š
                        if shot.get('ref', False):
                            print(f"  [Painter] âš ï¸ è­¦å‘Š: Shot {shot_id} è®¾ä¸º ref=trueï¼Œä½†åœ¨ {ref_image_dir} ä¸­æœªæ‰¾åˆ°å›¾ç‰‡ï¼Œæ›´æ”¹ä¸ºæ–‡ç”Ÿå›¾ã€‚")
                else:
                    # è‹¥é•œå¤´æ˜¾å¼è¦æ±‚å‚è€ƒå›¾ä½†æœªæä¾› ref_image_dirï¼Œåˆ™æç¤ºç”¨æˆ·
                    if wants_ref and shot.get('ref', False):
                        print(f"  [Painter] âš ï¸ è­¦å‘Š: Shot {shot_id} è®¾ä¸º ref=trueï¼Œä½†æœªæä¾› ref_image_dir å‚æ•°ã€‚")

                # è‹¥æ‰¾åˆ°äº† ref_public_urlï¼Œåˆ™å¯ç”¨å‚è€ƒå›¾ç”Ÿå›¾ï¼›å¦åˆ™èµ°æ–‡ç”Ÿå›¾
                # å¦‚æœä¸Šä¸€æ­¥æ²¡æ‹¿åˆ°å‚è€ƒå›¾ï¼Œä½†åˆ†é•œè‡ªå¸¦ keyframe_urlï¼ˆdata URI / http(s) / file://ï¼‰ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨
                if wants_ref and (not ref_public_url):
                    keyframe = shot.get("keyframe_url")
                    if isinstance(keyframe, str) and keyframe.strip():
                        k = keyframe.strip()
                        if k.startswith("file://"):
                            local_path = file_url_to_local_path(k)
                            # ä¼˜å…ˆä¸Šä¼ åˆ°å›¾åºŠè·å–çŸ­ URLï¼›ä¸Šä¼ å¤±è´¥åˆ™é™çº§ä¸ºæ–‡ç”Ÿå›¾ï¼ˆä¸ä½¿ç”¨å‚è€ƒå›¾ï¼‰
                            if os.path.isdir(local_path):
                                # è‹¥æ˜¯ç›®å½•ï¼ˆGradio ä¸´æ—¶ç›®å½•ï¼‰ï¼Œå¤ç”¨ enhanced_prompt çš„é€»è¾‘æŒ‘é€‰æ–‡ä»¶åå†å¤„ç†
                                try:
                                    from enhanced_prompt import _pick_local_image_file  # type: ignore
                                    picked = _pick_local_image_file(local_path)
                                except Exception:
                                    picked = None
                                ref_public_url = self._local_image_to_ref_url(picked) if picked else None
                            else:
                                ref_public_url = self._local_image_to_ref_url(local_path)
                            if not ref_public_url and shot.get('ref', False):
                                msg = f"Shot {shot_id}: keyframe_url ä¸ºæœ¬åœ°æ–‡ä»¶ä½†ä¸Šä¼ å¤±è´¥ï¼Œå·²æ”¹ä¸ºæ–‡ç”Ÿå›¾ï¼ˆå›¾ç‰‡æœªä½¿ç”¨ï¼‰ã€‚"
                                warnings.append(msg)
                                print(f"  [Painter] âš ï¸ {msg}")
                        elif k.startswith("data:"):
                            # å…è®¸ data URIï¼ˆä»…åœ¨å·¥å…·å†…éƒ¨ä½¿ç”¨ï¼Œä¸å›ä¼ ï¼‰ï¼›ä½†é™åˆ¶é•¿åº¦ï¼Œé¿å…è¯·æ±‚ä½“è¿‡å¤§
                            MAX_DATA_URI_CHARS = 3_000_000
                            if len(k) > MAX_DATA_URI_CHARS:
                                msg = f"Shot {shot_id}: å‚è€ƒå›¾ data URI è¿‡å¤§ï¼Œå·²å¿½ç•¥å‚è€ƒå›¾ï¼ˆå›¾ç‰‡æœªä½¿ç”¨ï¼‰ã€‚"
                                warnings.append(msg)
                                print(f"  [Painter] âš ï¸ {msg}")
                            else:
                                ref_public_url = k
                        else:
                            if k.startswith("http://") or k.startswith("https://"):
                                ref_public_url = k
                            else:
                                msg = f"Shot {shot_id}: keyframe_url ä¸æ˜¯æœ‰æ•ˆçš„ http(s) URLï¼Œå·²å¿½ç•¥å‚è€ƒå›¾ï¼ˆå›¾ç‰‡æœªä½¿ç”¨ï¼‰ã€‚"
                                warnings.append(msg)
                                print(f"  [Painter] âš ï¸ {msg}")
                        if ref_public_url:
                            print(f"  [Painter] âœ… ä½¿ç”¨åˆ†é•œè‡ªå¸¦ keyframe_url ä½œä¸ºå‚è€ƒå›¾ (Shot {shot_id})")

                use_ref = bool(ref_public_url)
                ref_image_used[shot_id] = use_ref

                if raw_prompt:
                    if max_workers > 1:
                        tasks.append(
                            {
                                "shot_id": str(shot_id),
                                "prompt": raw_prompt,
                                "ref_public_url": ref_public_url,
                                "use_ref": use_ref,
                            }
                        )
                    else:
                        local_path = self._generate_image(
                            raw_prompt, shot_id, task_dir, resolution, style_modifier, ref_public_url, use_ref
                        )
                        if local_path:
                            generated_files.append(local_path)
                            image_by_shot[str(shot_id)] = local_path
                            images_with_shot_id.append({"shot_id": str(shot_id), "image_url": local_path})
                        else:
                            failed_shots.append(shot_id)
                else:
                    print(f"  [Painter] âš ï¸ é•œå¤´ {shot_id} ç¼ºå°‘æç¤ºè¯ï¼Œè·³è¿‡ã€‚")

            # å¹¶è¡Œæ‰§è¡Œï¼šæŠŠ API è°ƒç”¨æ”¾åˆ°çº¿ç¨‹æ± é‡Œï¼ˆé¢„å¤„ç†åœ¨ä¸»çº¿ç¨‹å®Œæˆï¼Œé¿å…å¹¶å‘ä¿®æ”¹ shot å­—æ®µï¼‰
            if max_workers > 1 and tasks:
                try:
                    print(f"  [Painter] å¹¶è¡Œæ¨¡å¼: max_workers={max_workers}, tasks={len(tasks)}")
                except Exception:
                    pass

                def _task_run(t: Dict[str, Any]):
                    sid = t["shot_id"]
                    img = self._generate_image(
                        t["prompt"], sid, task_dir, resolution, style_modifier, t.get("ref_public_url"), t.get("use_ref", False)
                    )
                    return sid, img

                with ThreadPoolExecutor(max_workers=max_workers) as ex:
                    futs = [ex.submit(_task_run, t) for t in tasks]
                    for fut in as_completed(futs):
                        try:
                            sid, local_path = fut.result()
                        except Exception as e:
                            warnings.append(f"parallel worker exception: {e}")
                            continue
                        if local_path:
                            generated_files.append(local_path)
                            image_by_shot[str(sid)] = local_path
                            images_with_shot_id.append({"shot_id": str(sid), "image_url": local_path})
                        else:
                            failed_shots.append(str(sid))

            # 5. è¿”å›ç»“æœ
            # è¿™é‡Œè¿”å›å…³é”®çš„ output_directoryï¼Œä¾›ä¸‹æ¸¸ Agent ä½¿ç”¨
            result = {
                "status": "success",
                "total_shots": len(shots_data),
                "success_count": len(generated_files),
                "output_directory": os.path.abspath(task_dir) if save_images else None, # ä»…è½ç›˜æ—¶è¿”å›ç›®å½•
                "images": generated_files,
                "image_by_shot": image_by_shot,
                "images_with_shot_id": images_with_shot_id,
                # ä»…è¿”å› http(s) URLï¼Œé¿å… base64 data URI å›æµ
                "ref_image_public_urls": {
                    k: v
                    for k, v in ref_image_public_urls.items()
                    if isinstance(v, str) and (v.startswith("http://") or v.startswith("https://"))
                },
                "ref_image_used": ref_image_used,
                "warnings": warnings,
                "failed_shots": failed_shots
            }
            return json.dumps(result, ensure_ascii=False)

        except Exception as e:
            return f"Error during batch painting: {str(e)}"

# ==============================================================================
# 2. Agent åŒ…è£…å™¨ (Agent æœ¬ä½“åªè´Ÿè´£è°ƒç”¨è¿™ä¸ª Tool)
# ==============================================================================

def init_painting_agent():
    tools = ['batch_storyboard_painter']
    
    # System Prompt æ›´æ–°ï¼šå‘ŠçŸ¥ Agent å®ƒæœ‰èƒ½åŠ›è°ƒæ•´ç”»è´¨
    system_instruction = (
        "ä½ æ˜¯ä¸€ä¸ªåˆ†é•œç»˜åˆ¶æ‰§è¡Œå®˜ã€‚"
        "ä½ çš„ä»»åŠ¡æ˜¯è°ƒç”¨ `batch_storyboard_painter` è¿›è¡Œç»˜å›¾ã€‚"
        "å¦‚æœä¸ç¡®å®šç”¨æˆ·çš„åˆ†è¾¨ç‡éœ€æ±‚ï¼Œé»˜è®¤ä½¿ç”¨ 1280*720ã€‚"
        "å¦‚æœç”¨æˆ·æä¾›äº†å‚è€ƒå›¾æ–‡ä»¶å¤¹ï¼ˆReference Image Directoryï¼‰ï¼Œè¯·åŠ¡å¿…åœ¨è°ƒç”¨å·¥å…·æ—¶ä¼ å…¥ `ref_image_dir` å‚æ•°ã€‚"
        "å¦‚æœç”¨æˆ·æœ‰ç‰¹å®šçš„é£æ ¼è¦æ±‚ï¼ˆå¦‚â€˜æ°´å¢¨ç”»â€™ã€â€˜èµ›åšæœ‹å…‹â€™ï¼‰ï¼Œè¯·å°†å…¶ä½œä¸º `style_modifier` å‚æ•°ä¼ å…¥ã€‚"
        "ä»»åŠ¡å®Œæˆåæ±‡æŠ¥ä¿å­˜è·¯å¾„ã€‚"
    )
    
    bot = Assistant(
        llm={'model': 'qwen-max'}, 
        name='Storyboard Painter',
        system_message=system_instruction,
        function_list=tools,
    )
    return bot

# ==============================================================================
# 3. æµ‹è¯•æµç¨‹
# ==============================================================================

def test_pipeline():
    # æ¨¡æ‹Ÿä¸Šä¸€æ­¥ Agent ç”Ÿæˆçš„æ–‡ä»¶è·¯å¾„
    # å®é™…ä½¿ç”¨æ—¶ï¼Œè¿™å°±æ˜¯ video_analyst ç”Ÿæˆçš„ prompts_xxxx.json
    input_json_path = "./storyboard_output/prompts_20251218_145455.json" 
    
    # --- æ„é€ æµ‹è¯•æ•°æ® (å¦‚æœä½ è¿˜æ²¡æœ‰ä¸Šä¸€æ­¥çš„æ–‡ä»¶) ---
    if not os.path.exists(input_json_path):
        os.makedirs(os.path.dirname(input_json_path), exist_ok=True)
        dummy_data = [
            {
                "shot_id": "01",
                # æ¨¡æ‹Ÿå¸¦æœ‰ MJ å‚æ•°çš„ Promptï¼Œæµ‹è¯•æ¸…æ´—åŠŸèƒ½
                "midjourney_prompt": "/imagine prompt: A cyberpunk cat sitting on a neon rooftop, raining night, cinematic lighting --ar 16:9 --v 6.0"
            },
            {
                "shot_id": "02",
                "midjourney_prompt": "Wide angle shot of a futuristic city with flying cars, blue and pink tone"
            }
        ]
        with open(input_json_path, 'w', encoding='utf-8') as f:
            json.dump(dummy_data, f)
        print(f"[*] å·²è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹: {input_json_path}")
    # ----------------------------------------

    # åˆå§‹åŒ– Agent
    bot = init_painting_agent()
    
    # å‘é€æŒ‡ä»¤
    query = f"è¯·æ ¹æ®è¿™ä¸ªæ–‡ä»¶ç”Ÿæˆåˆ†é•œå›¾ç‰‡ï¼š{input_json_path}"
    print(f"User: {query}")
    print("-" * 50)
    
    messages = [{'role': 'user', 'content': query}]
    
    for response in bot.run(messages=messages):
        print(response)

# æµ‹è¯•æ–°åŠ çš„æŒ‡å®šåˆ†è¾¨ç‡å’ŒæŒ‡å®šé£æ ¼
def test_interactive_mode():
    bot = init_painting_agent()
    json_file = "./storyboard_output/prompts_20251218_145455.json"
    ref_dir = "./test_refs"

    # --- åœºæ™¯ 1ï¼šç”¨æˆ·æŒ‡å®šåˆ†è¾¨ç‡å’Œé£æ ¼ ---
    user_query = f"ç”¨è¿™ä¸ªæ–‡ä»¶ç”Ÿæˆå›¾ç‰‡ï¼š{json_file}ã€‚å‚è€ƒå›¾åœ¨è¿™ä¸ªæ–‡ä»¶å¤¹ï¼š{ref_dir}ã€‚æˆ‘è¦ 1024*1024 çš„æ­£æ–¹å½¢å›¾ç‰‡ï¼Œå¹¶ä¸”å¸Œæœ›æ•´ä½“é£æ ¼åå‘â€˜å‰åœåŠ›åŠ¨ç”»é£æ ¼â€™ã€‚"
    
    print(f"User: {user_query}")
    print("-" * 50)
    
    messages = [{'role': 'user', 'content': user_query}]
    
    # Call: batch_storyboard_painter(json_path="...", resolution="1024*1024", style_modifier="Ghibli studio style")
    for response in bot.run(messages=messages):
        print(response)

if __name__ == '__main__':
    # test_pipeline()
    test_interactive_mode()
